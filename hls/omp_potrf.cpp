///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: omp_potrf
// Accel. type hash: 5840911080
// Num. instances: 1
// Wrapper version: 13
///////////////////

#include <math.h>
#include <hls_stream.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>

static ap_uint<64> __mcxx_taskId;
template<class T>
union __mcxx_cast {
   unsigned long long int raw;
   T typed;
};
struct mcxx_inaxis {
   ap_uint<64> data;
};
typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

constexpr int ts = 256;
constexpr unsigned int FPGA_PWIDTH = 256;
void omp_potrf_moved(float A[ts*ts])
{
#pragma HLS inline
#pragma HLS array_partition variable=A cyclic factor=FPGA_PWIDTH/64
  for (int j = 0; j < ts;  ++j)
    {
      float tmp = A[j * ts + j];
      for (int k = 0; k < j;  k += 2)
        {
#pragma HLS pipeline II=1
          const float Akj1 = A[k * ts + j];
          const float Akj2 = k+1 < j ? A[(k+1)*ts + j] : 0;
          tmp -= Akj1 * Akj1 + Akj2*Akj2;
        }
      A[j * ts + j] = sqrtf(tmp);
      for (int i = j + 1; i < ts;  ++i)
        {
          float tmp = A[j * ts + i];
          for (int k = 0; k < j;  k += 2)
            {
#pragma HLS pipeline II=1
              const float aux = k+1 < j ? A[(k+1) * ts + i] * A[(k+1) * ts + j] : 0;
              tmp -= A[k * ts + i] * A[k * ts + j] + aux;
            }
          A[j * ts + i] = tmp / A[j * ts + j];
        }
    }
}

void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   mcxx_outaxis axis_word;
   axis_word.data = data;
   axis_word.dest = dest;
   axis_word.last = last;
   mcxx_outPort.write(axis_word);
}

void omp_potrf_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, ap_uint<256>* mcxx_memport) {
#pragma HLS interface ap_ctrl_none port=return
#pragma HLS interface axis port=mcxx_inPort
#pragma HLS interface axis port=mcxx_outPort
#pragma HLS interface m_axi port=mcxx_memport
   static float A[ts*ts];
   mcxx_inPort.read(); //command word
   __mcxx_taskId = mcxx_inPort.read();
   ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
   ap_uint<8> mcxx_flags_0;
   ap_uint<64> mcxx_offset_0;
   {
      #pragma HLS protocol fixed
      {
         mcxx_flags_0 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_0 = mcxx_inPort.read();
      }
      ap_wait();
   }
   if (mcxx_flags_0[4]) {
	  copy_in:
      for (int __i = 0; __i < (((4L) * (ts*ts)) - 1)/sizeof(ap_uint<256>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<256> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<256>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<256>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            A[__i*(sizeof(ap_uint<256>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   omp_potrf_moved(A);
   if (mcxx_flags_0[5]) {
	  copy_out:
      for (int __i = 0; __i < (((4L) * (ts*ts)) - 1)/sizeof(ap_uint<256>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<256> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<256>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = A[__i*(sizeof(ap_uint<256>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<256>)+ __i) = __tmpBuffer;
      }
   }
   {
      #pragma HLS protocol fixed
      ap_uint<64> header = 0x03;
      ap_wait();
      mcxx_write_out_port(header, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
      ap_wait();
   }
}
