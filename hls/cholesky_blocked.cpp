///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: cholesky_blocked
// Accel. type hash: 6274650572
// Num. instances: 1
// Wrapper version: 13
///////////////////

#include <hls_stream.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>

typedef unsigned int uint;

static ap_uint<64> __mcxx_taskId;
template<class T>
union __mcxx_cast {
	unsigned long long int raw;
	T typed;
};
struct mcxx_inaxis {
	ap_uint<64> data;
};
typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;
struct __fpga_copyinfo_t {
	unsigned long long int copy_address;
	unsigned char arg_idx;
	unsigned char flags;
	unsigned int size;
};
struct __data_owner_info_t {
	unsigned long long int size;
	unsigned char owner;
};

void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], int numDataOwners, __data_owner_info_t data_owners[], hls::stream<mcxx_outaxis>& mcxx_outPort, unsigned char owner);
void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort);
template <typename T>
struct __mcxx_ptr_t {
	unsigned long long int val;
	__mcxx_ptr_t(unsigned long long int val) : val(val) {}
	__mcxx_ptr_t() {}
	inline operator __mcxx_ptr_t<const T>() const {
		return __mcxx_ptr_t<const T>(val);
	}
	template <typename V> inline __mcxx_ptr_t<T> operator+(V const val) const {
		return __mcxx_ptr_t<T>(this->val + val*sizeof(T));
	}
	template <typename V> inline __mcxx_ptr_t<T> operator-(V const val) const {
		return __mcxx_ptr_t<T>(this->val - val*sizeof(T));
	}
	template <typename V> inline operator V() const {
		return (V)val;
	}
};

static inline int get_block_idx(uint i, uint j, uint nt, unsigned char r, unsigned char s, const ap_uint<2> cfidx, const uint ndiags, const unsigned char remstart)
{
#pragma HLS inline
	uint cf;
	uint globaln = i+j;
	uint n = globaln/s;
	if (cfidx == 0)
		cf = 0;
	else if (cfidx == 1)
		cf = (n+1)/2;
	else if (cfidx == 2)
		cf = (n+1)/4;
	else
		cf = (n+2)/4;
	uint rem = n - ndiags;
	uint remblocks = (rem+1)*remstart + s*((rem*(rem+1))/2) + (rem+1);
	uint nblocks = (s*n*(n+1) + 2*(n+1)*r)/4 + (n+1) - cf - (globaln >= nt ? remblocks : 0);
	uint block_idx = nblocks - ((r + n*s)/2 + 1) + (globaln >= nt ? remstart + rem*s + 1 : 0) + (globaln >= nt ? nt-1-i : j);
	return block_idx;
}

unsigned char calc_owner(int i, int j, unsigned char size) {
#pragma HLS inline
	return (i + j)%size;
}

constexpr unsigned long long int ts = 256;
constexpr unsigned int recv_buffer_size = 2;

void cholesky_blocked_moved(const uint nt, __mcxx_ptr_t<float> A, __mcxx_ptr_t<float> recv_buffer, unsigned char __ompif_rank, unsigned char __ompif_size, hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort)
{
#pragma HLS inline
	unsigned char r = __ompif_rank;
	unsigned char s = __ompif_size;
	ap_uint<2> cfidx;
	uint ndiags = nt/s + (r < nt%s ? 1 : 0);
	unsigned char remstart = r >= nt%s ? r-nt%s : r+s - nt%s;
	if (s%2 == 0 && r%2 == 0)
		cfidx = 0;
	else if (s%2 == 0 && r%2 == 1)
		cfidx = 1;
	else if (s%2 == 1 && r%2 == 0)
		cfidx = 2;
	else
		cfidx = 3;
	main_loop:
	for (uint k = 0; k < nt; k++)
	{
		{
			const unsigned char task_owner = calc_owner(k, k, s);
			uint A_idx;
			if (task_owner == r)
				A_idx = get_block_idx(k, k, nt, r, s, cfidx, ndiags, remstart);
			unsigned long long int __mcxx_args[1L];
			unsigned long long int __mcxx_deps[1L];
			__fpga_copyinfo_t __mcxx_copies[1L];
			__mcxx_ptr_t<float> __mcxx_arg_0;
			__mcxx_arg_0 = A + A_idx*ts*ts;
			__mcxx_args[0] = __mcxx_arg_0.val;
			const __fpga_copyinfo_t tmp_0 = {.copy_address = __mcxx_arg_0.val, .arg_idx = 0, .flags = 3, .size = ts*ts * sizeof(float)};
			__mcxx_copies[0] = tmp_0;
			__mcxx_ptr_t<float> __mcxx_dep_0;
			__mcxx_dep_0 = A + A_idx*ts*ts;
			__mcxx_deps[0] = 3LLU << 58 | __mcxx_dep_0.val;
			mcxx_task_create(5840911080LLU, 255, 1, __mcxx_args, 1, __mcxx_deps, 1, __mcxx_copies, 0, 0, mcxx_outPort, task_owner);
		}

		inner_loop:
		for (uint i = k + 1; i < nt; i++)
		{
			{
				const unsigned char task_owner = calc_owner(i, k, s);
				const unsigned char data_owner0 = calc_owner(k, k, s);
				__mcxx_ptr_t<float> Ablock, Bblock;
				if (task_owner == r && data_owner0 != r)
					Ablock = recv_buffer + ((k%recv_buffer_size)*nt)*ts*ts;
				else if (data_owner0 == r) {
					uint A_idx = get_block_idx(k, k, nt, r, s, cfidx, ndiags, remstart);
					Ablock = A + A_idx*ts*ts;
				}
				if (task_owner == r) {
					uint B_idx = get_block_idx(i, k, nt, r, s, cfidx, ndiags, remstart);
					Bblock = A + B_idx*ts*ts;
				}
				unsigned long long int __mcxx_args[2L];
				unsigned long long int __mcxx_deps[2L];
				__fpga_copyinfo_t __mcxx_copies[2L];
				__mcxx_ptr_t<float> __mcxx_arg_0;
				__mcxx_arg_0 = Ablock;
				__mcxx_args[0] = __mcxx_arg_0.val;
				const __fpga_copyinfo_t tmp_0 = {.copy_address = __mcxx_arg_0.val, .arg_idx = 0, .flags = 1, .size = ts*ts * sizeof(const float)};
				__mcxx_copies[0] = tmp_0;
				__mcxx_ptr_t<float> __mcxx_arg_1;
				__mcxx_arg_1 = Bblock;
				__mcxx_args[1] = __mcxx_arg_1.val;
				const __fpga_copyinfo_t tmp_1 = {.copy_address = __mcxx_arg_1.val, .arg_idx = 1, .flags = 3, .size = ts*ts * sizeof(float)};
				__mcxx_copies[1] = tmp_1;
				__mcxx_ptr_t<float> __mcxx_dep_0;
				__mcxx_dep_0 = Ablock;
				__mcxx_deps[0] = 1LLU << 58 | __mcxx_dep_0.val;
				__mcxx_ptr_t<float> __mcxx_dep_1;
				__mcxx_dep_1 = Bblock;
				__mcxx_deps[1] = 3LLU << 58 | __mcxx_dep_1.val;
				__data_owner_info_t data_owners[1];
				const ap_uint<1> n_data_owners = i-(k+1) < __ompif_size ? 1 : 0;
				const __data_owner_info_t owner_0 = {.size=ts*ts*sizeof(float), .owner=data_owner0};
				data_owners[0] = owner_0;
				mcxx_task_create(6757884748LLU, 255, 2, __mcxx_args, 2, __mcxx_deps, 2, __mcxx_copies, n_data_owners, data_owners, mcxx_outPort, task_owner);
			}
			gemm_loop:
			for (uint j = k + 1; j < i; j++)
			{
				{
					const unsigned char task_owner = calc_owner(i, j, s);
					const unsigned char data_owner0 = calc_owner(i, k, s);
					const unsigned char data_owner1 = calc_owner(j, k, s);
					__mcxx_ptr_t<float> Ablock, Bblock, Cblock;
					if (task_owner == r && data_owner0 != r)
						Ablock = recv_buffer + ((k%recv_buffer_size)*nt + i)*ts*ts;
					else if (data_owner0 == r) {
						uint A_idx = get_block_idx(i, k, nt, r, s, cfidx, ndiags, remstart);
						Ablock = A + A_idx*ts*ts;
					}
					if (task_owner == r && data_owner1 != r)
						Bblock = recv_buffer + ((k%recv_buffer_size)*nt + j)*ts*ts;
					else if (data_owner1 == r) {
						uint B_idx = get_block_idx(j, k, nt, r, s, cfidx, ndiags, remstart);
						Bblock = A + B_idx*ts*ts;
					}
					if (task_owner == r) {
						uint C_idx = get_block_idx(i, j, nt, r, s, cfidx, ndiags, remstart);
						Cblock = A + C_idx*ts*ts;
					}
					unsigned long long int __mcxx_args[3L];
					unsigned long long int __mcxx_deps[3L];
					__fpga_copyinfo_t __mcxx_copies[3L];
					__mcxx_ptr_t<float> __mcxx_arg_0;
					__mcxx_arg_0 = Ablock;
					__mcxx_args[0] = __mcxx_arg_0.val;
					const __fpga_copyinfo_t tmp_0 = {.copy_address = __mcxx_arg_0.val, .arg_idx = 0, .flags = 1, .size = ts*ts * sizeof(const float)};
					__mcxx_copies[0] = tmp_0;
					__mcxx_ptr_t<float> __mcxx_arg_1;
					__mcxx_arg_1 = Bblock;
					__mcxx_args[1] = __mcxx_arg_1.val;
					const __fpga_copyinfo_t tmp_1 = {.copy_address = __mcxx_arg_1.val, .arg_idx = 1, .flags = 1, .size = ts*ts * sizeof(const float)};
					__mcxx_copies[1] = tmp_1;
					__mcxx_ptr_t<float> __mcxx_arg_2;
					__mcxx_arg_2 = Cblock;
					__mcxx_args[2] = __mcxx_arg_2.val;
					const __fpga_copyinfo_t tmp_2 = {.copy_address = __mcxx_arg_2.val, .arg_idx = 2, .flags = 3, .size = ts*ts * sizeof(float)};
					__mcxx_copies[2] = tmp_2;
					__mcxx_ptr_t<float> __mcxx_dep_0;
					__mcxx_dep_0 = Ablock;
					__mcxx_deps[0] = 1LLU << 58 | __mcxx_dep_0.val;
					__mcxx_ptr_t<float> __mcxx_dep_1;
					__mcxx_dep_1 = Bblock;
					__mcxx_deps[1] = 1LLU << 58 | __mcxx_dep_1.val;
					__mcxx_ptr_t<float> __mcxx_dep_2;
					__mcxx_dep_2 = Cblock;
					__mcxx_deps[2] = 3LLU << 58 | __mcxx_dep_2.val;
					__data_owner_info_t data_owners[2];
					const __data_owner_info_t owner_0 = {.size=ts*ts*sizeof(float), .owner=data_owner0};
					const __data_owner_info_t owner_1 = {.size=ts*ts*sizeof(float), .owner=data_owner1};
					data_owners[0] = owner_0;
					data_owners[1] = owner_1;
					ap_uint<2> n_data_owners;
					if (i-(k+1) < __ompif_size)
						n_data_owners = 2;
					else if (j-(k+1) < __ompif_size)
						n_data_owners = 1;
					else
						n_data_owners = 0;
					mcxx_task_create(6757388164LLU, 255, 3, __mcxx_args, 3, __mcxx_deps, 3, __mcxx_copies, n_data_owners, data_owners, mcxx_outPort, task_owner);
				}
			}
			{
				const unsigned char task_owner = calc_owner(i, i, s);
				const unsigned char data_owner0 = calc_owner(i, k, s);
				__mcxx_ptr_t<float> Ablock, Bblock;
				if (task_owner == r && data_owner0 != r)
					Ablock = recv_buffer + ((k%recv_buffer_size)*nt + i)*ts*ts;
				else if (data_owner0 == r) {
					uint A_idx = get_block_idx(i, k, nt, r, s, cfidx, ndiags, remstart);
					Ablock = A + A_idx*ts*ts;
				}
				if (task_owner == r) {
					uint B_idx = get_block_idx(i, i, nt, r, s, cfidx, ndiags, remstart);
					Bblock = A + B_idx*ts*ts;
				}
				unsigned long long int __mcxx_args[2L];
				unsigned long long int __mcxx_deps[2L];
				__fpga_copyinfo_t __mcxx_copies[2L];
				__mcxx_ptr_t<float> __mcxx_arg_0;
				__mcxx_arg_0 = Ablock;
				__mcxx_args[0] = __mcxx_arg_0.val;
				const __fpga_copyinfo_t tmp_0 = {.copy_address = __mcxx_arg_0.val, .arg_idx = 0, .flags = 1, .size = ts*ts * sizeof(const float)};
				__mcxx_copies[0] = tmp_0;
				__mcxx_ptr_t<float> __mcxx_arg_1;
				__mcxx_arg_1 = Bblock;
				__mcxx_args[1] = __mcxx_arg_1.val;
				const __fpga_copyinfo_t tmp_1 = {.copy_address = __mcxx_arg_1.val, .arg_idx = 1, .flags = 3, .size = ts*ts * sizeof(float)};
				__mcxx_copies[1] = tmp_1;
				__mcxx_ptr_t<float> __mcxx_dep_0;
				__mcxx_dep_0 = Ablock;
				__mcxx_deps[0] = 1LLU << 58 | __mcxx_dep_0.val;
				__mcxx_ptr_t<float> __mcxx_dep_1;
				__mcxx_dep_1 = Bblock;
				__mcxx_deps[1] = 3LLU << 58 | __mcxx_dep_1.val;
				__data_owner_info_t data_owners[1];
				const __data_owner_info_t owner_0 = {.size=ts*ts*sizeof(float), .owner=data_owner0};
				data_owners[0] = owner_0;
				const ap_uint<1> n_data_owners = i-(k+1) < __ompif_size ? 1 : 0;
				mcxx_task_create(6757855513LLU, 255, 2, __mcxx_args, 2, __mcxx_deps, 2, __mcxx_copies, n_data_owners, data_owners, mcxx_outPort, task_owner);
			}
		}
	}
	mcxx_taskwait(mcxx_spawnInPort, mcxx_outPort);
}

void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
	mcxx_outaxis axis_word;
	axis_word.data = data;
	axis_word.dest = dest;
	axis_word.last = last;
	mcxx_outPort.write(axis_word);
}

void cholesky_blocked_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, hls::stream<ap_uint<8> >& mcxx_spawnInPort, ap_uint<8> ompif_rank, ap_uint<8> ompif_size) {
#pragma HLS interface ap_ctrl_none port=return
#pragma HLS interface axis port=mcxx_inPort
#pragma HLS interface axis port=mcxx_outPort
#pragma HLS interface axis port=mcxx_spawnInPort
#pragma HLS stable variable=ompif_rank
#pragma HLS stable variable=ompif_size
	mcxx_inPort.read(); //command word
	__mcxx_taskId = mcxx_inPort.read();
	ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
	unsigned long long int nt;
	__mcxx_ptr_t<float> A;
	{
#pragma HLS protocol fixed
		{
			ap_uint<8> mcxx_flags_0;
			ap_uint<64> mcxx_offset_0;
			mcxx_flags_0 = mcxx_inPort.read()(7,0);
			ap_wait();
			__mcxx_cast<unsigned long long int> mcxx_arg_0;
			mcxx_arg_0.raw = mcxx_inPort.read();
			nt = mcxx_arg_0.typed;
		}
		ap_wait();
		{
			ap_uint<8> mcxx_flags_1;
			ap_uint<64> mcxx_offset_1;
			mcxx_flags_1 = mcxx_inPort.read()(7,0);
			ap_wait();
			mcxx_offset_1 = mcxx_inPort.read();
			A.val = mcxx_offset_1;
		}
		ap_wait();
	}
	cholesky_blocked_moved(nt, A, ompif_rank, ompif_size, mcxx_spawnInPort, mcxx_outPort);
	{
#pragma HLS protocol fixed
		ap_uint<64> header = 0x03;
		ap_wait();
		mcxx_write_out_port(header, 0, 0, mcxx_outPort);
		ap_wait();
		mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
		ap_wait();
		mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
		ap_wait();
	}
}

void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], const ap_uint<8> numDataOwners, __data_owner_info_t data_owners[], hls::stream<mcxx_outaxis>& mcxx_outPort, unsigned char ompif_rank, unsigned char ompif_size, unsigned char owner) {
#pragma HLS inline
	const ap_uint<2> destId = 2;
	ap_uint<64> tmp;
	tmp(15,8)  = numArgs;
	tmp(23,16) = numDeps;
	tmp(31,24) = numCopies;
	tmp(39,32) = numDataOwners;
	tmp(47,40) = owner;
	mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
	mcxx_write_out_port(__mcxx_taskId, destId, 0, mcxx_outPort);
	tmp(47,40) = instanceNum;
	tmp(33,0)  = type(33,0);
	mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
	for (ap_uint<4> i = 0; i < numDeps(3,0); ++i) {
#pragma HLS unroll
		if (i < numDataOwners) {
			ap_uint<64> ownerdata;
			ownerdata(7,0) = data_owners[i].owner;
			ownerdata(63,32) = data_owners[i].size;
			mcxx_write_out_port(ownerdata, destId, 0, mcxx_outPort);
		}
		mcxx_write_out_port(deps[i], destId, numArgs == 0 && numCopies == 0 && i == numDeps-1, mcxx_outPort);
	}
	for (ap_uint<4> i = 0; i < numCopies(3,0); ++i) {
#pragma HLS unroll
		mcxx_write_out_port(copies[i].copy_address, destId, 0, mcxx_outPort);
		tmp(7,0) = copies[i].flags;
		tmp(15,8) = copies[i].arg_idx;
		tmp(63,32) = copies[i].size;
		mcxx_write_out_port(tmp, destId, numArgs == 0 && i == numCopies-1, mcxx_outPort);
	}
	for (ap_uint<4> i = 0; i < numArgs(3,0); ++i) {
#pragma HLS unroll
		mcxx_write_out_port(args[i], destId, i == numArgs-1, mcxx_outPort);
	}
}

void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
	ap_wait();
	mcxx_write_out_port(__mcxx_taskId, 3, 1, mcxx_outPort);
	ap_wait();
	mcxx_spawnInPort.read();
	ap_wait();
}
