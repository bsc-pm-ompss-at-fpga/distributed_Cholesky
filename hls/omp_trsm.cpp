///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: omp_trsm
// Accel. type hash: 6757884748
// Num. instances: 1
// Wrapper version: 13
///////////////////

#include <hls_stream.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>

static ap_uint<64> __mcxx_taskId;
template<class T>
union __mcxx_cast {
   unsigned long long int raw;
   T typed;
};
struct mcxx_inaxis {
   ap_uint<64> data;
};
typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

constexpr int FPGA_OTHER_II = 4;
constexpr int ts = 256;
constexpr unsigned int FPGA_PWIDTH = 256;

void omp_trsm_moved(const float A[ts*ts], float B[ts*ts])
{
  float tmp_row[ts];
#pragma HLS inline
#pragma HLS array_partition variable=A cyclic factor=FPGA_PWIDTH/64
#pragma HLS array_partition variable=B cyclic factor=ts/FPGA_OTHER_II
#pragma HLS array_partition variable=tmp_row cyclic factor=ts/(2*FPGA_OTHER_II)
  for (int k = 0; k < ts;  ++k)
    {
      float temp = 1.00000000000000000000000000000000000000000000000000000e+00 / A[k * ts + k];
      for (int i = 0; i < ts;  ++i)
        {
#pragma HLS unroll factor=ts/FPGA_OTHER_II
#pragma HLS pipeline II=1
#pragma HLS DEPENDENCE variable=B inter false
          B[k * ts + i] = tmp_row[i] = temp * B[k * ts + i];
        }
      for (int j = k + 1; j < ts;  ++j)
        {
#pragma HLS pipeline II=FPGA_OTHER_II
#pragma HLS DEPENDENCE variable=B inter false
          for (int i = 0; i < ts;  ++i)
            {
              B[j * ts + i] -= A[k * ts + j] * tmp_row[i];
            }
        }
    }
}

void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
#pragma HLS inline
   mcxx_outaxis axis_word;
   axis_word.data = data;
   axis_word.dest = dest;
   axis_word.last = last;
   mcxx_outPort.write(axis_word);
}

void omp_trsm_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, ap_uint<256>* mcxx_memport) {
#pragma HLS interface ap_ctrl_none port=return
#pragma HLS interface axis port=mcxx_inPort
#pragma HLS interface axis port=mcxx_outPort
#pragma HLS interface m_axi port=mcxx_memport
   static float B[ts*ts];
   static float A[ts*ts];
   mcxx_inPort.read(); //command word
   __mcxx_taskId = mcxx_inPort.read();
   ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
   ap_uint<8> mcxx_flags_0;
   ap_uint<64> mcxx_offset_0;
   ap_uint<8> mcxx_flags_1;
   ap_uint<64> mcxx_offset_1;
   {
      #pragma HLS protocol fixed
      {
         mcxx_flags_0 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_0 = mcxx_inPort.read();
      }
      ap_wait();
      {
         mcxx_flags_1 = mcxx_inPort.read()(7,0);
         ap_wait();
         mcxx_offset_1 = mcxx_inPort.read();
      }
      ap_wait();
   }
   if (mcxx_flags_1[4]) {
      for (int __i = 0; __i < (((4L) * (ts*ts)) - 1)/sizeof(ap_uint<256>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<256> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<256>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<256>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            B[__i*(sizeof(ap_uint<256>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   if (mcxx_flags_0[4]) {
      for (int __i = 0; __i < (((4L) * (ts*ts)) - 1)/sizeof(ap_uint<256>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<256> __tmpBuffer;
         __tmpBuffer = *(mcxx_memport + mcxx_offset_0/sizeof(ap_uint<256>) + __i);
         for (int __j=0; __j <(sizeof(ap_uint<256>)/4); __j++) {
            __mcxx_cast<const float> cast_tmp;
            cast_tmp.raw = __tmpBuffer((__j+1)*4*8-1,__j*4*8);
            A[__i*(sizeof(ap_uint<256>)/4)+__j] = cast_tmp.typed;
         }
      }
   }
   omp_trsm_moved(A, B);
   if (mcxx_flags_1[5]) {
      for (int __i = 0; __i < (((4L) * (ts*ts)) - 1)/sizeof(ap_uint<256>)+1; ++__i) {
      #pragma HLS pipeline II=1
         ap_uint<256> __tmpBuffer;
         for (int __j=0; __j <(sizeof(ap_uint<256>)/4); __j++) {
            __mcxx_cast<float> cast_tmp;
            cast_tmp.typed = B[__i*(sizeof(ap_uint<256>)/4)+__j];
            __tmpBuffer((__j+1)*4*8-1,__j*4*8) = cast_tmp.raw;
         }
         *(mcxx_memport + mcxx_offset_1/sizeof(ap_uint<256>)+ __i) = __tmpBuffer;
      }
   }
   {
      #pragma HLS protocol fixed
      ap_uint<64> header = 0x03;
      ap_wait();
      mcxx_write_out_port(header, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
      ap_wait();
      mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
      ap_wait();
   }
}
